# vsg_core/subtitles/pgs/__init__.py
# -*- coding: utf-8 -*-
"""
PGS (Presentation Graphic Stream) subtitle OCR system.
Extracts and OCRs PGS subtitles from Blu-ray .sup files.
"""
from __future__ import annotations
from pathlib import Path
from typing import Optional, List
from .models import SubtitleEntry, PcsData
from .parser import PgsParser
from .image import composite_objects, crop_transparent
from .preprocessor import PreprocessSettings, preprocess_for_ocr
from .ocr_tesseract import run_ocr_with_postprocessing, find_tesseract


def calculate_ass_position(
    x: int,
    y: int,
    width: int,
    height: int,
    video_width: int,
    video_height: int
) -> tuple[int, int, int]:
    """
    Calculate ASS alignment and position from PGS coordinates.

    Args:
        x: Subtitle X position
        y: Subtitle Y position
        width: Subtitle width
        height: Subtitle height
        video_width: Video width
        video_height: Video height

    Returns:
        Tuple of (alignment, pos_x, pos_y)

        Alignment (numpad layout):
            1=bottom-left, 2=bottom-center, 3=bottom-right
            4=middle-left, 5=center,        6=middle-right
            7=top-left,    8=top-center,    9=top-right
    """
    # Calculate center of subtitle
    center_x = x + width / 2
    center_y = y + height / 2

    # Determine alignment based on position
    y_percent = center_y / video_height
    x_percent = center_x / video_width

    # Vertical alignment
    if y_percent > 0.8:
        v_align = 0  # bottom (1, 2, 3)
    elif y_percent < 0.2:
        v_align = 6  # top (7, 8, 9)
    else:
        v_align = 3  # middle (4, 5, 6)

    # Horizontal alignment
    if x_percent < 0.33:
        h_align = 0  # left
    elif x_percent > 0.67:
        h_align = 2  # right
    else:
        h_align = 1  # center

    alignment = v_align + h_align + 1

    # Calculate position based on alignment anchor
    if h_align == 0:  # left
        pos_x = x
    elif h_align == 2:  # right
        pos_x = x + width
    else:  # center
        pos_x = int(center_x)

    if v_align == 0:  # bottom
        pos_y = y + height
    elif v_align == 6:  # top
        pos_y = y
    else:  # middle
        pos_y = int(center_y)

    return (alignment, pos_x, pos_y)


def generate_ass_output(
    subtitles: List[SubtitleEntry],
    video_width: int,
    video_height: int,
    output_path: str
) -> None:
    """
    Generate ASS subtitle file with positioning.

    Args:
        subtitles: List of subtitle entries
        video_width: Video width for PlayResX
        video_height: Video height for PlayResY
        output_path: Output .ass file path
    """
    lines = [
        "[Script Info]",
        f"; Generated by Video-Sync-GUI PGS OCR",
        f"PlayResX: {video_width}",
        f"PlayResY: {video_height}",
        "ScaledBorderAndShadow: yes",
        "",
        "[V4+ Styles]",
        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding",
        "Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1",
        "",
        "[Events]",
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"
    ]

    for sub in subtitles:
        dialogue = sub.to_ass_dialogue()
        lines.append(dialogue)

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))


def extract_pgs_subtitles(
    sup_file: str,
    output_file: Optional[str] = None,
    lang: str = 'eng',
    video_width: int = 1920,
    video_height: int = 1080,
    from_matroska: bool = False,
    tesseract_path: Optional[str] = None,
    preprocess_settings: Optional[PreprocessSettings] = None,
    log_callback=None,
    save_debug_images: bool = False
) -> Optional[str]:
    """
    Extract and OCR PGS subtitles from .sup file.

    This is the main entry point for PGS OCR processing.

    Args:
        sup_file: Path to .sup file
        output_file: Output .ass file path (auto-generated if None)
        lang: Tesseract language code (default 'eng')
        video_width: Video width for positioning (default 1920)
        video_height: Video height for positioning (default 1080)
        from_matroska: If True, SUP is in Matroska format
        tesseract_path: Path to tesseract executable (auto-detect if None)
        preprocess_settings: Image preprocessing settings (use defaults if None)
        log_callback: Optional callback function for logging (receives string messages)

    Returns:
        Path to generated .ass file, or None on failure
    """
    def log(message: str):
        """Helper to log messages"""
        if log_callback:
            log_callback(message)
        else:
            print(message)

    # Validate input
    sup_path = Path(sup_file)
    if not sup_path.exists():
        log(f"[PGS OCR] ERROR: File not found: {sup_file}")
        return None

    # Check tesseract
    if tesseract_path is None:
        tesseract_path = find_tesseract()
    if tesseract_path is None:
        log("[PGS OCR] ERROR: Tesseract not found. Please install Tesseract OCR.")
        return None

    log(f"[PGS OCR] Using Tesseract: {tesseract_path}")

    # Set output file
    if output_file is None:
        output_file = str(sup_path.with_suffix('.ass'))

    # Use default preprocessing settings if not provided
    if preprocess_settings is None:
        preprocess_settings = PreprocessSettings()

    try:
        # Step 1: Parse SUP file
        log(f"[PGS OCR] Parsing {sup_path.name}...")
        parser = PgsParser(from_matroska=from_matroska)
        compositions = parser.parse_file(str(sup_path))

        if not compositions:
            log("[PGS OCR] ERROR: No subtitles found in file")
            return None

        log(f"[PGS OCR] Found {len(compositions)} subtitles")

        # Step 2: Process each subtitle
        subtitles: List[SubtitleEntry] = []

        for i, pcs in enumerate(compositions):
            if not pcs.has_complete_data():
                log(f"[PGS OCR] Skipping subtitle {i+1}: incomplete data")
                continue

            log(f"[PGS OCR] Processing subtitle {i+1}/{len(compositions)}...")

            try:
                # Decompress and composite image
                result = composite_objects(pcs, use_bt709=False)
                if result is None:
                    log(f"[PGS OCR] Skipping subtitle {i+1}: failed to create image")
                    continue

                image, offset_x, offset_y = result

                # Crop transparent borders
                if preprocess_settings.crop_transparent:
                    image, crop_left, crop_top = crop_transparent(image, preprocess_settings.crop_max)
                    offset_x += crop_left
                    offset_y += crop_top

                # Store image dimensions
                img_width, img_height = image.size

                # Preprocess for OCR
                processed = preprocess_for_ocr(image, preprocess_settings)

                # Save debug images if requested
                if save_debug_images:
                    debug_dir = Path(sup_path).parent / "pgs_debug"
                    debug_dir.mkdir(exist_ok=True)
                    try:
                        image.save(debug_dir / f"sub_{i+1:04d}_original.png")
                        processed.save(debug_dir / f"sub_{i+1:04d}_processed.png")
                        log(f"[PGS OCR] Debug images saved to {debug_dir}")
                    except Exception as e:
                        log(f"[PGS OCR] Warning: Could not save debug images: {e}")

                # Run OCR - Try multiple PSM modes if first fails
                text = ""

                # Try PSM 7 first (single text line - best for subtitles)
                text = run_ocr_with_postprocessing(
                    processed,
                    lang=lang,
                    psm=7,  # Single text line
                    tesseract_path=tesseract_path
                )

                # If PSM 7 failed, try PSM 6 (uniform block)
                if not text.strip():
                    text = run_ocr_with_postprocessing(
                        processed,
                        lang=lang,
                        psm=6,  # Uniform block
                        tesseract_path=tesseract_path
                    )

                # If still no text, try PSM 3 (fully automatic)
                if not text.strip():
                    text = run_ocr_with_postprocessing(
                        processed,
                        lang=lang,
                        psm=3,  # Fully automatic
                        tesseract_path=tesseract_path
                    )

                if not text.strip():
                    log(f"[PGS OCR] Warning: No text extracted from subtitle {i+1}")
                    continue

                # Calculate ASS position
                alignment, pos_x, pos_y = calculate_ass_position(
                    offset_x, offset_y,
                    img_width, img_height,
                    video_width, video_height
                )

                # Create subtitle entry
                entry = SubtitleEntry(
                    start_ms=pcs.start_time_ms,
                    end_ms=pcs.end_time_ms or pcs.start_time_ms + 3000,
                    text=text,
                    x=pos_x,
                    y=pos_y,
                    width=img_width,
                    height=img_height,
                    is_forced=pcs.objects[0].is_forced if pcs.objects else False,
                    alignment=alignment
                )

                subtitles.append(entry)
                log(f"[PGS OCR]   -> '{text[:50]}...' at ({pos_x}, {pos_y})")

            except Exception as e:
                log(f"[PGS OCR] Error processing subtitle {i+1}: {e}")
                continue

        if not subtitles:
            log("[PGS OCR] ERROR: No subtitles successfully OCR'd")
            return None

        # Step 3: Generate ASS output
        log(f"[PGS OCR] Generating ASS file: {output_file}")
        generate_ass_output(subtitles, video_width, video_height, output_file)

        log(f"[PGS OCR] Successfully created {output_file} with {len(subtitles)} subtitles")
        return output_file

    except Exception as e:
        log(f"[PGS OCR] ERROR: {e}")
        import traceback
        traceback.print_exc()
        return None


__all__ = [
    'extract_pgs_subtitles',
    'PreprocessSettings',
    'SubtitleEntry',
    'PcsData',
]
