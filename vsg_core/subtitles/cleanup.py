# vsg_core/subtitles/cleanup.py
# -*- coding: utf-8 -*-
from __future__ import annotations
import re
from pathlib import Path
from collections import defaultdict
import pysubs2
import enchant

class SubtitleCleaner:
    """
    Cleans and analyzes SRT files generated by an OCR process.
    Applies specific, dictionary-guarded fixes and reports on potential issues.
    """
    def __init__(self, subtitle_path: str, config: dict, custom_wordlist: set = None):
        self.path = Path(subtitle_path)
        self.config = config
        self.subs = pysubs2.load(subtitle_path, encoding='utf-8')
        self.report = defaultdict(int)

        # Common OCR mistakes that should always be fixed
        self.always_fix = {
            # Common I/l confusion patterns
            'l\'m': "I'm",
            'l\'ve': "I've",
            'l\'ll': "I'll",
            'l\'d': "I'd",
            'lt\'s': "It's",
            'ln': "In",
            'ls': "Is",
            'lf': "If",
        }

        try:
            self.dictionary = enchant.Dict("en_US")
            # Add common proper nouns and technical terms
            default_additions = {
                'okay', 'OK', 'yeah', 'gonna', 'wanna', 'gotta',
                'ain\'t', 'y\'all', 'ma\'am', 'sir'
            }
            for word in default_additions:
                self.dictionary.add_to_session(word)

            if custom_wordlist:
                for word in custom_wordlist:
                    self.dictionary.add_to_session(word)
        except enchant.errors.DictNotFoundError:
            self.dictionary = None
            print("[WARN] OCR Cleanup: 'en_US' dictionary not found. Using pattern-based fixes only.")

    def cleanup(self) -> dict:
        """
        Runs the full cleanup and analysis process on the loaded subtitle file.
        Returns a dictionary containing the report of all changes and findings.
        """
        for line in self.subs:
            original_text = line.text
            text = original_text

            # Apply always-fix patterns first
            for wrong, right in self.always_fix.items():
                if wrong in text:
                    text = text.replace(wrong, right)
                    self.report['fixed_common_patterns'] += 1

            # Fix standalone 'l' to 'I'
            text = re.sub(r'\bl\b', 'I', text)
            if text != original_text:
                self.report['fixed_standalone_l_to_i'] += 1

            # Fix capital I in middle of words to lowercase l
            text = re.sub(r'(?<=[a-z])I(?=[a-z])', 'l', text)
            if 'I' in original_text and 'l' in text:
                self.report['fixed_i_in_word_to_l'] += 1

            # Process word by word for trailing l/ll fixes
            words = text.split()
            modified_words = []

            for word in words:
                # Skip if word is empty
                if not word:
                    modified_words.append(word)
                    continue

                # Remove trailing punctuation for analysis
                cleaned_word = re.sub(r'[.,?!"\'()\[\]]+$', '', word)

                # Skip empty cleaned words
                if not cleaned_word:
                    modified_words.append(word)
                    continue

                # Check if word should be protected by dictionary
                if self.dictionary and self._is_valid_word(cleaned_word):
                    modified_words.append(word)
                    self.report['words_shielded_by_dict'] += 1
                    continue

                # Apply trailing l/ll fixes
                if cleaned_word.endswith('ll') and not self._is_valid_word(cleaned_word[:-2] + '!!'):
                    # Check if replacing 'll' with '!!' makes sense
                    # (avoid changing valid words like 'well', 'tell', etc.)
                    if not self._is_likely_valid_ll_ending(cleaned_word):
                        modified_word = re.sub(r'll$', '!!', word)
                        modified_words.append(modified_word)
                        self.report['fixed_trailing_ll'] += 1
                    else:
                        modified_words.append(word)
                elif cleaned_word.endswith('l') and not self._is_valid_word(cleaned_word):
                    # Check if this might be an exclamation
                    if self._could_be_exclamation(cleaned_word):
                        modified_word = re.sub(r'l$', '!', word)
                        modified_words.append(modified_word)
                        self.report['fixed_trailing_l'] += 1
                    else:
                        modified_words.append(word)
                else:
                    modified_words.append(word)

            text = " ".join(modified_words)

            # Remove spaces before punctuation
            text = re.sub(r'\s+([!?])', r'\1', text)
            if ' !' in original_text or ' ?' in original_text:
                self.report['removed_spaces_before_punctuation'] += 1

            # Normalize ellipsis if configured
            if self.config.get('ocr_cleanup_normalize_ellipsis', False):
                ellipsis_count = text.count('…')
                text = text.replace('…', '...')
                if ellipsis_count > 0:
                    self.report['normalized_ellipsis'] += ellipsis_count

            # Fix common OCR patterns
            text = self._fix_common_ocr_errors(text)

            # Update the subtitle line
            line.text = text

            # Generate warnings for potential issues
            if text.count('"') % 2 != 0 or text.count("'") % 2 != 0:
                self.report['quote_balance_warnings'] += 1
            if '|' in text:
                self.report['stray_pipes'] += 1
            if '~' in text:
                self.report['stray_tildes'] += 1

        # Save the cleaned subtitles
        self.subs.save(str(self.path), encoding='utf-8')
        return dict(self.report)

    def _is_valid_word(self, word: str) -> bool:
        """Check if a word is valid according to the dictionary."""
        if not self.dictionary:
            return False

        # Check the word as-is
        if self.dictionary.check(word):
            return True

        # Check lowercase version
        if self.dictionary.check(word.lower()):
            return True

        # Check if it's a contraction
        if "'" in word:
            base = word.split("'")[0]
            if self.dictionary.check(base):
                return True

        return False

    def _is_likely_valid_ll_ending(self, word: str) -> bool:
        """Check if a word ending in 'll' is likely valid."""
        common_ll_words = {
            'all', 'call', 'fall', 'hall', 'ball', 'wall', 'tall', 'small',
            'will', 'still', 'till', 'fill', 'kill', 'bill', 'hill', 'mill',
            'well', 'tell', 'sell', 'fell', 'bell', 'cell', 'hell', 'spell',
            'full', 'pull', 'bull', 'null', 'dull', 'skull',
            'roll', 'poll', 'toll', 'doll', 'scroll',
            'shall', 'install', 'recall', 'overall'
        }
        return word.lower() in common_ll_words or (self.dictionary and self.dictionary.check(word))

    def _could_be_exclamation(self, word: str) -> bool:
        """Determine if a word ending in 'l' could be an exclamation ending in '!'."""
        # Common exclamations that might be OCR'd wrong
        exclamations = {
            'nol': 'no!',
            'yesl': 'yes!',
            'helpl': 'help!',
            'stopl': 'stop!',
            'waitl': 'wait!',
            'lookl': 'look!',
            'gol': 'go!',
            'runl': 'run!',
            'ohi': 'oh!',
            'ahl': 'ah!',
            'owI': 'ow!',
        }

        # Check if it matches a known exclamation pattern
        if word.lower() in exclamations:
            return True

        # Check if the word without 'l' is valid and short (likely an exclamation)
        word_without_l = word[:-1]
        if len(word_without_l) <= 5:
            if self.dictionary and self.dictionary.check(word_without_l):
                return True

        return False

    def _fix_common_ocr_errors(self, text: str) -> str:
        """Fix additional common OCR errors."""
        # Fix rn -> m confusion (common in some fonts)
        patterns = [
            (r'\brn([aeiou])', r'm\1'),  # rn before vowel -> m
            (r'([aeiou])rn\b', r'\1m'),  # rn after vowel at word end -> m
        ]

        for pattern, replacement in patterns:
            old_text = text
            text = re.sub(pattern, replacement, text)
            if text != old_text:
                self.report['fixed_rn_to_m'] += 1

        return text


def run_cleanup(subtitle_path: str, config: dict, runner) -> dict:
    """
    Public function to instantiate and run the cleaner.
    """
    try:
        custom_wordlist = set()
        wordlist_path_str = config.get('ocr_cleanup_custom_wordlist_path')

        if wordlist_path_str:
            wordlist_path = Path(wordlist_path_str)
            if wordlist_path.is_file():
                try:
                    with open(wordlist_path, 'r', encoding='utf-8') as f:
                        custom_words = {line.strip() for line in f if line.strip()}
                    custom_wordlist = custom_words
                    runner._log_message(f"[OCR Cleanup] Loaded {len(custom_wordlist)} words from custom wordlist.")
                except Exception as e:
                    runner._log_message(f"[WARN] OCR Cleanup: Could not read custom wordlist file: {e}")
            else:
                runner._log_message(f"[WARN] OCR Cleanup: Custom wordlist file not found at '{wordlist_path}'.")

        cleaner = SubtitleCleaner(subtitle_path, config, custom_wordlist=custom_wordlist)
        report = cleaner.cleanup()

        runner._log_message(f"[OCR Cleanup] Cleaned '{Path(subtitle_path).name}'.")

        # Don't log the report here - let the caller handle it
        # to avoid duplicate output

        return report

    except Exception as e:
        runner._log_message(f"[OCR Cleanup] ERROR: Failed to process '{Path(subtitle_path).name}': {e}")
        return {}
