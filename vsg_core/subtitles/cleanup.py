# vsg_core/subtitles/cleanup.py
# -*- coding: utf-8 -*-
from __future__ import annotations
import re
from pathlib import Path
from collections import defaultdict
import pysubs2

class SubtitleCleaner:
    """
    Cleans and analyzes SRT files generated by an OCR process,
    applying specific fixes and reporting on potential issues.
    """
    def __init__(self, subtitle_path: str, config: dict):
        self.path = Path(subtitle_path)
        self.config = config
        self.subs = pysubs2.load(subtitle_path, encoding='utf-8')
        self.report = defaultdict(int)

    def cleanup(self) -> dict:
        """
        Runs the full cleanup and analysis process on the loaded subtitle file.
        Returns a dictionary containing the report of all changes and findings.
        """
        # --- Define Regex Patterns ---
        # SAFE version for 'll' -> '!!', requires preceding space or start of line.
        trailing_ll_re = re.compile(r'(?:(?<=^)|(?<=\s))ll(?=$|[\s"”’\'\)\]\.?!…-])')

        # SAFE version for 'l' -> '!', using chained negative lookbehinds to
        # correctly exclude words ending in 'al', 'el', 'il', 'ol', 'ul'.
        trailing_l_re = re.compile(
            r'(?<!al)(?<!el)(?<!il)(?<!ol)(?<!ul)(?<![a-zA-Z])l(?=$|[\s"”’\'\)\]\.?!…-])',
            re.IGNORECASE
        )

        # Fixes for 'I' vs 'l' confusion.
        standalone_l_re = re.compile(r'\bl\b')
        i_in_word_re = re.compile(r'(?<=[a-z])I(?=[a-z])')

        # General cleanup
        space_before_punct_re = re.compile(r'\s+([!?])')

        for line in self.subs:
            original_text = line.text

            # --- Apply Fixes in Order ---
            # 1. Fix 'l' vs 'I' confusion
            text, count = standalone_l_re.subn('I', original_text)
            if count > 0: self.report['fixed_standalone_l_to_i'] += count

            text, count = i_in_word_re.subn('l', text)
            if count > 0: self.report['fixed_i_in_word_to_l'] += count

            # 2. Trailing 'll' -> '!!'
            text, count = trailing_ll_re.subn('!!', text)
            if count > 0: self.report['fixed_trailing_ll'] += count

            # 3. Trailing 'l' -> '!'
            text, count = trailing_l_re.subn('!', text)
            if count > 0: self.report['fixed_trailing_l'] += count

            # 4. Space before '!' or '?'
            new_text, count = space_before_punct_re.subn(r'\1', text)
            if count > 0:
                if '!' in text: self.report['removed_space_before_bang'] += text.count(' !')
                if '?' in text: self.report['removed_space_before_qmark'] += text.count(' ?')
            text = new_text

            # 5. Ellipsis normalization (if enabled)
            if self.config.get('ocr_cleanup_normalize_ellipsis', False):
                text, count = re.subn('…', '...', text)
                if count > 0: self.report['normalized_ellipsis'] += count

            line.text = text

            # --- Generate Flags/Reports (on the final, cleaned text) ---
            if text.count('"') % 2 != 0 or text.count("'") % 2 != 0:
                self.report['quote_balance_warnings'] += 1
            if '|' in text:
                self.report['stray_pipes'] += 1
            if '!!' in text: self.report['punct_runs_bangbang'] += 1
            if '?!' in text or '!?' in text: self.report['punct_runs_qbang'] += 1
            if '...' in text or '…' in text: self.report['punct_runs_ellipsis'] += 1
            if '!!!' in text: self.report['punct_runs_triplebang'] += 1
            if re.search(r'\.\.\.?!|!\?!', text): self.report['punct_runs_mixed'] += 1

        # Save the modified file
        self.subs.save(str(self.path), encoding='utf-8')

        return dict(self.report)

def run_cleanup(subtitle_path: str, config: dict, runner) -> dict:
    """
    Public function to instantiate and run the cleaner.
    """
    try:
        cleaner = SubtitleCleaner(subtitle_path, config)
        report = cleaner.cleanup()
        runner._log_message(f"[OCR Cleanup] Cleaned '{Path(subtitle_path).name}'.")
        return report
    except Exception as e:
        runner._log_message(f"[OCR Cleanup] ERROR: Failed to process '{Path(subtitle_path).name}': {e}")
        return {}
