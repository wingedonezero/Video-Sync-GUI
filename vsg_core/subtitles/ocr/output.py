# vsg_core/subtitles/ocr/output.py
# -*- coding: utf-8 -*-
"""
Subtitle Output Generation

Generates ASS (Advanced SubStation Alpha) or SRT subtitle files from OCR results.

Features:
    - ASS output with position tags for non-bottom subtitles
    - Configurable bottom position threshold
    - SRT fallback (no position support)
    - Style configuration

Position handling:
    - Bottom subtitles (> threshold): Use default alignment
    - Top subtitles (< 25%): Use \\an8 (top center)
    - Middle subtitles: Use \\pos(x,y) explicit positioning
"""

from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple
import re


@dataclass
class OutputConfig:
    """Configuration for subtitle output."""
    # Format
    output_format: str = 'ass'  # 'ass' or 'srt'

    # Position handling
    preserve_positions: bool = True
    bottom_threshold_percent: float = 75.0  # Below this = not bottom
    top_threshold_percent: float = 25.0  # Above this = top

    # ASS style settings
    style_name: str = 'Default'
    font_name: str = 'Arial'
    font_size: int = 48
    primary_color: str = '&H00FFFFFF'  # White
    outline_color: str = '&H00000000'  # Black
    outline_width: float = 2.0
    shadow_depth: float = 1.0
    margin_v: int = 30  # Vertical margin from bottom

    # Video resolution (for position scaling)
    video_width: int = 1920
    video_height: int = 1080


@dataclass
class SubtitleEntry:
    """A single subtitle entry for output."""
    index: int
    start_ms: int
    end_ms: int
    text: str
    x: int = 0
    y: int = 0
    frame_width: int = 720
    frame_height: int = 480
    is_forced: bool = False


class SubtitleWriter:
    """
    Writes subtitle files in ASS or SRT format.

    Handles position preservation for non-bottom subtitles.
    """

    def __init__(self, config: Optional[OutputConfig] = None):
        self.config = config or OutputConfig()

    def write(
        self,
        subtitles: List[SubtitleEntry],
        output_path: Path,
        format_override: Optional[str] = None
    ):
        """
        Write subtitles to file.

        Args:
            subtitles: List of subtitle entries
            output_path: Output file path
            format_override: Override output format ('ass' or 'srt')
        """
        fmt = format_override or self.config.output_format

        if fmt.lower() == 'srt':
            self._write_srt(subtitles, output_path)
        else:
            self._write_ass(subtitles, output_path)

    def _write_ass(self, subtitles: List[SubtitleEntry], output_path: Path):
        """Write ASS format with position support."""
        lines = []

        # Script Info section
        lines.extend([
            '[Script Info]',
            '; Generated by Video-Sync-GUI OCR System',
            f'PlayResX: {self.config.video_width}',
            f'PlayResY: {self.config.video_height}',
            'ScriptType: v4.00+',
            'WrapStyle: 0',
            'ScaledBorderAndShadow: yes',
            '',
        ])

        # Styles section
        lines.extend([
            '[V4+ Styles]',
            'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, '
            'OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, '
            'ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, '
            'MarginL, MarginR, MarginV, Encoding',
        ])

        # Default style
        style_line = (
            f'Style: {self.config.style_name},{self.config.font_name},'
            f'{self.config.font_size},{self.config.primary_color},'
            f'&H000000FF,{self.config.outline_color},&H00000000,'
            f'0,0,0,0,100,100,0,0,1,{self.config.outline_width},'
            f'{self.config.shadow_depth},2,10,10,{self.config.margin_v},1'
        )
        lines.append(style_line)

        # Top-aligned style (for top-positioned subtitles)
        top_style_line = (
            f'Style: Top,{self.config.font_name},'
            f'{self.config.font_size},{self.config.primary_color},'
            f'&H000000FF,{self.config.outline_color},&H00000000,'
            f'0,0,0,0,100,100,0,0,1,{self.config.outline_width},'
            f'{self.config.shadow_depth},8,10,10,{self.config.margin_v},1'
        )
        lines.append(top_style_line)
        lines.append('')

        # Events section
        lines.extend([
            '[Events]',
            'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text',
        ])

        # Add dialogue lines
        for sub in subtitles:
            start = self._ms_to_ass_time(sub.start_ms)
            end = self._ms_to_ass_time(sub.end_ms)
            text = self._escape_ass_text(sub.text)

            # Determine positioning
            position_info = self._determine_position(sub)
            style = self.config.style_name
            pos_tag = ''

            if position_info['type'] == 'top':
                style = 'Top'
            elif position_info['type'] == 'middle' and self.config.preserve_positions:
                # Scale position to output resolution
                scaled_x, scaled_y = self._scale_position(
                    sub.x + sub.frame_width // 2,  # Use center X
                    sub.y + 10,  # Offset slightly from top of subtitle
                    sub.frame_width,
                    sub.frame_height
                )
                pos_tag = f'{{\\pos({scaled_x},{scaled_y})}}'

            # Build dialogue line
            dialogue = f'Dialogue: 0,{start},{end},{style},,0,0,0,,{pos_tag}{text}'
            lines.append(dialogue)

        # Write file
        with open(output_path, 'w', encoding='utf-8-sig') as f:
            f.write('\n'.join(lines))

    def _write_srt(self, subtitles: List[SubtitleEntry], output_path: Path):
        """Write SRT format (no position support)."""
        lines = []

        for i, sub in enumerate(subtitles, 1):
            start = self._ms_to_srt_time(sub.start_ms)
            end = self._ms_to_srt_time(sub.end_ms)
            text = sub.text.strip()

            lines.extend([
                str(i),
                f'{start} --> {end}',
                text,
                '',
            ])

        # Write file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))

    def _determine_position(self, sub: SubtitleEntry) -> dict:
        """
        Determine position type for a subtitle.

        Returns:
            Dict with 'type' key: 'bottom', 'top', or 'middle'
        """
        if sub.frame_height == 0:
            return {'type': 'bottom'}

        # Calculate center Y position as percentage
        center_y = sub.y + (sub.frame_height * 0.05)  # Approximate subtitle height
        y_percent = (center_y / sub.frame_height) * 100

        if y_percent >= self.config.bottom_threshold_percent:
            return {'type': 'bottom'}
        elif y_percent <= self.config.top_threshold_percent:
            return {'type': 'top'}
        else:
            return {'type': 'middle', 'x': sub.x, 'y': sub.y}

    def _scale_position(
        self,
        x: int,
        y: int,
        source_width: int,
        source_height: int
    ) -> Tuple[int, int]:
        """
        Scale position from source resolution to output resolution.

        Args:
            x, y: Position in source coordinates
            source_width, source_height: Source video dimensions

        Returns:
            Scaled (x, y) for output resolution
        """
        if source_width == 0 or source_height == 0:
            return x, y

        scale_x = self.config.video_width / source_width
        scale_y = self.config.video_height / source_height

        return int(x * scale_x), int(y * scale_y)

    def _escape_ass_text(self, text: str) -> str:
        """Escape special characters for ASS format."""
        # Replace newlines with ASS line break
        text = text.replace('\n', '\\N')

        # Escape backslashes that aren't part of ASS tags
        # (but preserve valid ASS override tags)
        # This is tricky - for now, just handle common cases
        text = text.replace('\\n', '\\N')  # Normalize line breaks

        return text

    @staticmethod
    def _ms_to_ass_time(ms: int) -> str:
        """Convert milliseconds to ASS time format (H:MM:SS.cc)."""
        if ms < 0:
            ms = 0
        hours = ms // 3600000
        ms %= 3600000
        minutes = ms // 60000
        ms %= 60000
        seconds = ms // 1000
        centiseconds = (ms % 1000) // 10
        return f'{hours}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}'

    @staticmethod
    def _ms_to_srt_time(ms: int) -> str:
        """Convert milliseconds to SRT time format (HH:MM:SS,mmm)."""
        if ms < 0:
            ms = 0
        hours = ms // 3600000
        ms %= 3600000
        minutes = ms // 60000
        ms %= 60000
        seconds = ms // 1000
        milliseconds = ms % 1000
        return f'{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}'


def create_writer(settings_dict: dict) -> SubtitleWriter:
    """
    Create subtitle writer from settings dictionary.

    Args:
        settings_dict: Application settings

    Returns:
        Configured SubtitleWriter
    """
    config = OutputConfig(
        output_format=settings_dict.get('ocr_output_format', 'ass'),
        preserve_positions=settings_dict.get('ocr_preserve_positions', True),
        bottom_threshold_percent=settings_dict.get('ocr_bottom_threshold', 75.0),
        video_width=settings_dict.get('ocr_video_width', 1920),
        video_height=settings_dict.get('ocr_video_height', 1080),
    )

    return SubtitleWriter(config)
