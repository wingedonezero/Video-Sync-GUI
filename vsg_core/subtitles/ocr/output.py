# vsg_core/subtitles/ocr/output.py
"""
Subtitle Output Generation

Generates ASS (Advanced SubStation Alpha) or SRT subtitle files from OCR results.

Features:
    - ASS output with position tags for non-bottom subtitles
    - Configurable bottom position threshold
    - SRT fallback (no position support)
    - Style configuration

Position handling:
    - Bottom subtitles (> threshold): Use default alignment
    - Top subtitles (< 25%): Use \\an8 (top center)
    - Middle subtitles: Use \\pos(x,y) explicit positioning
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..data import SubtitleData


@dataclass
class OutputConfig:
    """Configuration for subtitle output."""
    # Format
    output_format: str = 'ass'  # 'ass' or 'srt'

    # Position handling
    preserve_positions: bool = True
    bottom_threshold_percent: float = 75.0  # Below this = not bottom
    top_threshold_percent: float = 25.0  # Above this = top

    # ASS style settings
    style_name: str = 'Default'
    font_name: str = 'Arial'
    font_size: int = 48
    primary_color: str = '&H00FFFFFF'  # White
    outline_color: str = '&H00000000'  # Black
    outline_width: float = 2.0
    shadow_depth: float = 1.0
    margin_v: int = 30  # Vertical margin from bottom

    # Video resolution (for position scaling)
    video_width: int = 1920
    video_height: int = 1080


@dataclass
class SubtitleEntry:
    """A single subtitle entry for output."""
    index: int
    start_ms: int
    end_ms: int
    text: str
    x: int = 0
    y: int = 0
    frame_width: int = 720
    frame_height: int = 480
    is_forced: bool = False


class SubtitleWriter:
    """
    Writes subtitle files in ASS or SRT format.

    Handles position preservation for non-bottom subtitles.
    """

    def __init__(self, config: OutputConfig | None = None):
        self.config = config or OutputConfig()

    def write(
        self,
        subtitles: list[SubtitleEntry],
        output_path: Path,
        format_override: str | None = None
    ):
        """
        Write subtitles to file.

        Args:
            subtitles: List of subtitle entries
            output_path: Output file path
            format_override: Override output format ('ass' or 'srt')
        """
        fmt = format_override or self.config.output_format

        if fmt.lower() == 'srt':
            self._write_srt(subtitles, output_path)
        else:
            self._write_ass(subtitles, output_path)

    def _write_ass(self, subtitles: list[SubtitleEntry], output_path: Path):
        """Write ASS format with position support."""
        lines = []

        # Script Info section
        lines.extend([
            '[Script Info]',
            '; Generated by Video-Sync-GUI OCR System',
            'Title: OCR Subtitles',
            'ScriptType: v4.00+',
            f'PlayResX: {self.config.video_width}',
            f'PlayResY: {self.config.video_height}',
            'WrapStyle: 0',
            'ScaledBorderAndShadow: yes',
            'Collisions: Normal',
            '',
        ])

        # Styles section
        lines.extend([
            '[V4+ Styles]',
            'Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, '
            'OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, '
            'ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, '
            'MarginL, MarginR, MarginV, Encoding',
        ])

        # Default style
        style_line = (
            f'Style: {self.config.style_name},{self.config.font_name},'
            f'{self.config.font_size},{self.config.primary_color},'
            f'&H000000FF,{self.config.outline_color},&H00000000,'
            f'0,0,0,0,100,100,0,0,1,{self.config.outline_width},'
            f'{self.config.shadow_depth},2,10,10,{self.config.margin_v},1'
        )
        lines.append(style_line)

        # Top-aligned style (for top-positioned subtitles)
        top_style_line = (
            f'Style: Top,{self.config.font_name},'
            f'{self.config.font_size},{self.config.primary_color},'
            f'&H000000FF,{self.config.outline_color},&H00000000,'
            f'0,0,0,0,100,100,0,0,1,{self.config.outline_width},'
            f'{self.config.shadow_depth},8,10,10,{self.config.margin_v},1'
        )
        lines.append(top_style_line)
        lines.append('')

        # Events section
        lines.extend([
            '[Events]',
            'Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text',
        ])

        # Add dialogue lines
        # Note: Position preservation is disabled - always use default bottom alignment
        # This matches behavior of SubtitleEdit and other tools which don't preserve
        # positions from VobSub/PGS sources because it's error-prone
        for sub in subtitles:
            start = self._ms_to_ass_time(sub.start_ms)
            end = self._ms_to_ass_time(sub.end_ms)
            text = self._escape_ass_text(sub.text)

            # Build dialogue line with default style (bottom center)
            dialogue = f'Dialogue: 0,{start},{end},{self.config.style_name},,0,0,0,,{text}'
            lines.append(dialogue)

        # Write file with Windows line endings (ASS standard)
        with open(output_path, 'w', encoding='utf-8-sig', newline='\r\n') as f:
            f.write('\n'.join(lines))

    def _write_srt(self, subtitles: list[SubtitleEntry], output_path: Path):
        """Write SRT format (no position support)."""
        lines = []

        for i, sub in enumerate(subtitles, 1):
            start = self._ms_to_srt_time(sub.start_ms)
            end = self._ms_to_srt_time(sub.end_ms)
            text = sub.text.strip()

            lines.extend([
                str(i),
                f'{start} --> {end}',
                text,
                '',
            ])

        # Write file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))

    def _determine_position(self, sub: SubtitleEntry) -> dict:
        """
        Determine position type for a subtitle.

        Returns:
            Dict with 'type' key: 'bottom', 'top', or 'middle'
        """
        if sub.frame_height == 0:
            return {'type': 'bottom'}

        # Calculate center Y position as percentage
        center_y = sub.y + (sub.frame_height * 0.05)  # Approximate subtitle height
        y_percent = (center_y / sub.frame_height) * 100

        if y_percent >= self.config.bottom_threshold_percent:
            return {'type': 'bottom'}
        elif y_percent <= self.config.top_threshold_percent:
            return {'type': 'top'}
        else:
            return {'type': 'middle', 'x': sub.x, 'y': sub.y}

    def _scale_position(
        self,
        x: int,
        y: int,
        source_width: int,
        source_height: int
    ) -> tuple[int, int]:
        """
        Scale position from source resolution to output resolution.

        Args:
            x, y: Position in source coordinates
            source_width, source_height: Source video dimensions

        Returns:
            Scaled (x, y) for output resolution
        """
        if source_width == 0 or source_height == 0:
            return x, y

        scale_x = self.config.video_width / source_width
        scale_y = self.config.video_height / source_height

        return int(x * scale_x), int(y * scale_y)

    def _escape_ass_text(self, text: str) -> str:
        """Escape special characters for ASS format."""
        # Replace newlines with ASS line break
        text = text.replace('\n', '\\N')

        # Escape backslashes that aren't part of ASS tags
        # (but preserve valid ASS override tags)
        # This is tricky - for now, just handle common cases
        text = text.replace('\\n', '\\N')  # Normalize line breaks

        return text

    @staticmethod
    def _ms_to_ass_time(ms: int) -> str:
        """Convert milliseconds to ASS time format (H:MM:SS.cc)."""
        ms = max(ms, 0)
        hours = ms // 3600000
        ms %= 3600000
        minutes = ms // 60000
        ms %= 60000
        seconds = ms // 1000
        centiseconds = (ms % 1000) // 10
        return f'{hours}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}'

    @staticmethod
    def _ms_to_srt_time(ms: int) -> str:
        """Convert milliseconds to SRT time format (HH:MM:SS,mmm)."""
        ms = max(ms, 0)
        hours = ms // 3600000
        ms %= 3600000
        minutes = ms // 60000
        ms %= 60000
        seconds = ms // 1000
        milliseconds = ms % 1000
        return f'{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}'


def create_writer(settings_dict: dict) -> SubtitleWriter:
    """
    Create subtitle writer from settings dictionary.

    Args:
        settings_dict: Application settings

    Returns:
        Configured SubtitleWriter
    """
    config = OutputConfig(
        output_format=settings_dict.get('ocr_output_format', 'ass'),
        preserve_positions=settings_dict.get('ocr_preserve_positions', True),
        bottom_threshold_percent=settings_dict.get('ocr_bottom_threshold', 75.0),
        video_width=settings_dict.get('ocr_video_width', 1920),
        video_height=settings_dict.get('ocr_video_height', 1080),
    )

    return SubtitleWriter(config)


# =============================================================================
# SubtitleData Conversion for Unified Pipeline
# =============================================================================

@dataclass
class OCRSubtitleResult:
    """
    Extended subtitle result with all OCR metadata for SubtitleData conversion.

    This carries all the data needed to populate SubtitleEvent.ocr and OCRMetadata.
    """
    index: int
    start_ms: float  # Float for precision
    end_ms: float
    text: str

    # OCR metadata
    confidence: float = 0.0
    raw_ocr_text: str = ''
    fixes_applied: dict = field(default_factory=dict)
    unknown_words: list[str] = field(default_factory=list)

    # Position data
    x: int = 0
    y: int = 0
    width: int = 0
    height: int = 0
    frame_width: int = 0
    frame_height: int = 0

    # VobSub specific
    is_forced: bool = False
    subtitle_colors: list[list[int]] = field(default_factory=list)
    dominant_color: list[int] = field(default_factory=list)

    # Debug image reference
    debug_image: str = ''  # e.g., "sub_0000.png"


def create_subtitle_data_from_ocr(
    ocr_results: list[OCRSubtitleResult],
    source_file: str,
    engine: str = 'tesseract',
    language: str = 'eng',
    source_format: str = 'vobsub',
    source_resolution: tuple[int, int] = (720, 480),
    output_resolution: tuple[int, int] = (1920, 1080),
    master_palette: list[list[int]] | None = None,
    config: OutputConfig | None = None
) -> 'SubtitleData':
    """
    Create SubtitleData from OCR results.

    This is the unified entry point for OCR -> SubtitleData conversion.
    All OCR metadata is preserved on each event.

    Args:
        ocr_results: List of OCRSubtitleResult with full metadata
        source_file: Original source file path
        engine: OCR engine used
        language: OCR language
        source_format: Source subtitle format (vobsub, pgs)
        source_resolution: Source video resolution
        output_resolution: Target video resolution
        master_palette: VobSub master palette (16 colors)
        config: Output configuration

    Returns:
        SubtitleData with all OCR metadata populated
    """
    from collections import OrderedDict

    from ..data import (
        OCREventData,
        OCRMetadata,
        SubtitleData,
        SubtitleEvent,
        SubtitleStyle,
    )

    config = config or OutputConfig()

    # Create SubtitleData
    data = SubtitleData()
    data.source_path = Path(source_file)
    data.source_format = 'ocr'
    data.encoding = 'utf-8'

    # Set up script info
    data.script_info = OrderedDict([
        ('Title', 'OCR Output'),
        ('ScriptType', 'v4.00+'),
        ('WrapStyle', '0'),
        ('ScaledBorderAndShadow', 'yes'),
        ('PlayResX', str(output_resolution[0])),
        ('PlayResY', str(output_resolution[1])),
    ])

    # Create default style
    default_style = SubtitleStyle(
        name='Default',
        fontname=config.font_name,
        fontsize=float(config.font_size),
        primary_color=config.primary_color,
        outline_color=config.outline_color,
        outline=config.outline_width,
        shadow=config.shadow_depth,
        alignment=2,  # Bottom center
        margin_v=config.margin_v,
    )

    # Create top style for positioned subtitles
    top_style = SubtitleStyle(
        name='Top',
        fontname=config.font_name,
        fontsize=float(config.font_size),
        primary_color=config.primary_color,
        outline_color=config.outline_color,
        outline=config.outline_width,
        shadow=config.shadow_depth,
        alignment=8,  # Top center
        margin_v=config.margin_v,
    )

    data.styles = OrderedDict([
        ('Default', default_style),
        ('Top', top_style),
    ])

    # Track statistics for OCRMetadata
    confidences = []
    total_fixes = 0
    fixes_by_type: dict = {}
    unknown_words_map: dict = {}  # word -> first occurrence info
    positioned_count = 0

    # Convert each OCR result to SubtitleEvent
    for result in ocr_results:
        # Escape text for ASS
        text = result.text.replace('\n', '\\N')

        # Create event
        event = SubtitleEvent(
            start_ms=float(result.start_ms),
            end_ms=float(result.end_ms),
            text=text,
            style='Default',
            original_index=result.index,
        )

        # Create OCR metadata for this event
        event.ocr = OCREventData(
            index=result.index,
            image=result.debug_image or f"sub_{result.index:04d}.png",
            confidence=result.confidence,
            raw_text=result.raw_ocr_text,
            fixes_applied=dict(result.fixes_applied),
            unknown_words=list(result.unknown_words),
            x=result.x,
            y=result.y,
            width=result.width,
            height=result.height,
            frame_width=result.frame_width,
            frame_height=result.frame_height,
            is_forced=result.is_forced,
            subtitle_colors=result.subtitle_colors,
            dominant_color=result.dominant_color,
        )

        # Track statistics
        confidences.append(result.confidence)

        for fix_name, count in result.fixes_applied.items():
            total_fixes += count
            fixes_by_type[fix_name] = fixes_by_type.get(fix_name, 0) + count

        for word in result.unknown_words:
            if word not in unknown_words_map:
                unknown_words_map[word] = {
                    'word': word,
                    'first_seen_index': result.index,
                    'occurrences': 0,
                }
            unknown_words_map[word]['occurrences'] += 1

        # Check if positioned
        if result.frame_height > 0:
            y_percent = (result.y / result.frame_height) * 100
            if y_percent < config.bottom_threshold_percent:
                positioned_count += 1

        data.events.append(event)

    # Create document-level OCR metadata
    data.ocr_metadata = OCRMetadata(
        engine=engine,
        language=language,
        source_format=source_format,
        source_file=source_file,
        source_resolution=list(source_resolution),
        master_palette=master_palette or [],
        total_subtitles=len(ocr_results),
        successful=len([r for r in ocr_results if r.text.strip()]),
        failed=len([r for r in ocr_results if not r.text.strip()]),
        average_confidence=sum(confidences) / len(confidences) if confidences else 0.0,
        min_confidence=min(confidences) if confidences else 0.0,
        max_confidence=max(confidences) if confidences else 0.0,
        total_fixes_applied=total_fixes,
        positioned_subtitles=positioned_count,
        fixes_by_type=fixes_by_type,
        unknown_words=[info for info in unknown_words_map.values()],
    )

    return data
