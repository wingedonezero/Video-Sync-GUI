//! ASS/SSA subtitle writer.
//!
//! Writes SubtitleData to ASS format.
//!
//! # Timing Precision
//!
//! ASS uses centisecond timing (H:MM:SS.cc). Internal float milliseconds
//! are rounded according to the configured RoundingMode at write time.

use crate::subtitles::types::{
    RoundingMode, SubtitleData, SubtitleEvent, SubtitleMetadata, SubtitleStyle, WriteOptions,
};

/// Write SubtitleData to ASS format string.
///
/// # Arguments
/// * `data` - The subtitle data to write.
/// * `options` - Write options (rounding mode, etc.).
///
/// # Returns
/// The ASS file content as a string.
pub fn write_ass(data: &SubtitleData, options: &WriteOptions) -> String {
    let mut output = String::new();

    // [Script Info]
    write_script_info(&mut output, &data.metadata);

    // [V4+ Styles]
    write_styles(&mut output, &data.styles);

    // [Events]
    write_events(&mut output, &data.events, options);

    output
}

/// Write [Script Info] section.
fn write_script_info(output: &mut String, metadata: &SubtitleMetadata) {
    output.push_str("[Script Info]\n");
    output.push_str("; Script generated by Video Sync GUI\n");

    if let Some(ref title) = metadata.title {
        output.push_str(&format!("Title: {}\n", title));
    }

    if let Some(ref script_type) = metadata.script_type {
        output.push_str(&format!("ScriptType: {}\n", script_type));
    } else {
        output.push_str("ScriptType: v4.00+\n");
    }

    if let Some(ref original) = metadata.original_script {
        output.push_str(&format!("Original Script: {}\n", original));
    }

    if let Some(ref translation) = metadata.translation {
        output.push_str(&format!("Original Translation: {}\n", translation));
    }

    if let Some(ref timing) = metadata.timing {
        output.push_str(&format!("Original Timing: {}\n", timing));
    }

    if let Some(x) = metadata.play_res_x {
        output.push_str(&format!("PlayResX: {}\n", x));
    }

    if let Some(y) = metadata.play_res_y {
        output.push_str(&format!("PlayResY: {}\n", y));
    }

    if let Some(wrap) = metadata.wrap_style {
        output.push_str(&format!("WrapStyle: {}\n", wrap));
    }

    if let Some(scaled) = metadata.scaled_border_and_shadow {
        output.push_str(&format!(
            "ScaledBorderAndShadow: {}\n",
            if scaled { "yes" } else { "no" }
        ));
    }

    if let Some(ref matrix) = metadata.ycbcr_matrix {
        output.push_str(&format!("YCbCr Matrix: {}\n", matrix));
    }

    // Custom fields
    for (key, value) in &metadata.custom {
        output.push_str(&format!("{}: {}\n", key, value));
    }

    output.push('\n');
}

/// Write [V4+ Styles] section.
fn write_styles(output: &mut String, styles: &[SubtitleStyle]) {
    output.push_str("[V4+ Styles]\n");
    output.push_str("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n");

    for style in styles {
        output.push_str(&format_style(style));
        output.push('\n');
    }

    output.push('\n');
}

/// Format a single style line.
fn format_style(style: &SubtitleStyle) -> String {
    format!(
        "Style: {},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}",
        style.name,
        style.fontname,
        style.fontsize,
        style.primary_color.to_ass_string(),
        style.secondary_color.to_ass_string(),
        style.outline_color.to_ass_string(),
        style.back_color.to_ass_string(),
        if style.bold { "-1" } else { "0" },
        if style.italic { "-1" } else { "0" },
        if style.underline { "-1" } else { "0" },
        if style.strikeout { "-1" } else { "0" },
        style.scale_x,
        style.scale_y,
        style.spacing,
        style.angle,
        style.border_style,
        style.outline,
        style.shadow,
        style.alignment,
        style.margin_l,
        style.margin_r,
        style.margin_v,
        style.encoding
    )
}

/// Write [Events] section.
fn write_events(output: &mut String, events: &[SubtitleEvent], options: &WriteOptions) {
    output.push_str("[Events]\n");
    output.push_str(
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n",
    );

    for event in events {
        output.push_str(&format_event(event, options));
        output.push('\n');
    }
}

/// Format a single event line.
fn format_event(event: &SubtitleEvent, options: &WriteOptions) -> String {
    let prefix = if event.is_comment {
        "Comment"
    } else {
        "Dialogue"
    };

    let start = format_ass_time(event.start_ms, options.rounding);
    let end = format_ass_time(event.end_ms, options.rounding);

    let style = event.style.as_deref().unwrap_or("Default");
    let actor = event.actor.as_deref().unwrap_or("");
    let effect = event.effect.as_deref().unwrap_or("");

    format!(
        "{}: {},{},{},{},{},{},{},{},{},{}",
        prefix,
        event.layer,
        start,
        end,
        style,
        actor,
        event.margin_l.unwrap_or(0),
        event.margin_r.unwrap_or(0),
        event.margin_v.unwrap_or(0),
        effect,
        event.text
    )
}

/// Format milliseconds as ASS timestamp (H:MM:SS.cc).
///
/// Applies rounding mode to convert float ms to centiseconds.
pub fn format_ass_time(ms: f64, rounding: RoundingMode) -> String {
    // Apply rounding (converts to centisecond precision)
    let ms = rounding.apply_ass(ms);

    let total_cs = (ms / 10.0).round() as u64;
    let cs = total_cs % 100;
    let total_secs = total_cs / 100;
    let secs = total_secs % 60;
    let total_mins = total_secs / 60;
    let mins = total_mins % 60;
    let hours = total_mins / 60;

    format!("{}:{:02}:{:02}.{:02}", hours, mins, secs, cs)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_ass_time() {
        assert_eq!(format_ass_time(0.0, RoundingMode::Round), "0:00:00.00");
        assert_eq!(format_ass_time(1000.0, RoundingMode::Round), "0:00:01.00");
        assert_eq!(format_ass_time(1500.0, RoundingMode::Round), "0:00:01.50");
        assert_eq!(format_ass_time(60000.0, RoundingMode::Round), "0:01:00.00");
        assert_eq!(format_ass_time(3600000.0, RoundingMode::Round), "1:00:00.00");

        // Test rounding modes
        assert_eq!(format_ass_time(1234.0, RoundingMode::Floor), "0:00:01.23");
        assert_eq!(format_ass_time(1234.0, RoundingMode::Round), "0:00:01.23");
        assert_eq!(format_ass_time(1235.0, RoundingMode::Round), "0:00:01.24");
        assert_eq!(format_ass_time(1234.0, RoundingMode::Ceil), "0:00:01.24");
    }

    #[test]
    fn test_write_basic_ass() {
        let mut data = SubtitleData::new();
        data.metadata.title = Some("Test".to_string());
        data.styles.push(SubtitleStyle::default());
        data.events
            .push(SubtitleEvent::new(1000.0, 4000.0, "Hello, world!"));
        data.events
            .push(SubtitleEvent::new(5000.0, 8000.0, "Test subtitle."));

        let options = WriteOptions::default();
        let output = write_ass(&data, &options);

        assert!(output.contains("[Script Info]"));
        assert!(output.contains("Title: Test"));
        assert!(output.contains("[V4+ Styles]"));
        assert!(output.contains("Style: Default"));
        assert!(output.contains("[Events]"));
        assert!(output.contains("Dialogue: 0,0:00:01.00,0:00:04.00"));
        assert!(output.contains("Hello, world!"));
    }

    #[test]
    fn test_round_trip() {
        use crate::subtitles::parsers::parse_ass;

        let original = r#"[Script Info]
Title: Round Trip Test
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:01.00,0:00:04.00,Default,,0,0,0,,Hello, world!
"#;

        let data = parse_ass(original).unwrap();
        let output = write_ass(&data, &WriteOptions::default());

        // Re-parse and compare
        let reparsed = parse_ass(&output).unwrap();

        assert_eq!(reparsed.metadata.title, data.metadata.title);
        assert_eq!(reparsed.styles.len(), data.styles.len());
        assert_eq!(reparsed.events.len(), data.events.len());
        assert!((reparsed.events[0].start_ms - data.events[0].start_ms).abs() < 10.0);
    }
}
