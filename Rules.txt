# AI Coding Rules (v3 - Rust Rewrite)

## 0) Prime Directive
- Prioritize correctness, clarity, maintainability, and reproducibility over cleverness.

## 1) Discuss Before Changes (Approval Required)
- Do not implement or refactor anything non-trivial until you:
  1. Explain the plan
  2. List files/functions impacted
  3. Call out risks/tradeoffs
  4. Get explicit approval
- Small, local fixes (typos, obvious bugfix in the same function) are allowed, but still explain what you changed.

## 2) Preserve Behavior by Default
- Maintain existing behavior unless an intentional change is explicitly approved.
- When changing behavior is necessary, clearly document:
  - What changes
  - Why it must change
  - How it's validated

## 3) Dependencies Are a Discussion
- Do not add new crates without proposing options + tradeoffs.
- Prefer fewer dependencies; justify any new one.
- If a crate's suitability is uncertain, stop and discuss first.

## 4) Research, Don't Assume
- When API/behavior is uncertain: consult official docs or upstream source.
- If you can't verify: say so and propose the safest path.

## 5) Code Style (Rust)
- Run `cargo fmt` before committing
- Run `cargo clippy` and address warnings
- Run `cargo test` to verify changes
- Follow existing patterns in the codebase

## 6) No Phantom Features
- Do NOT implement UI controls for features that don't have working backend code
- Do NOT stub out functions with `todo!()` or `unimplemented!()` unless explicitly approved
- Do NOT add settings/options for unimplemented functionality
- If backend code doesn't exist yet, the UI button/field shouldn't exist either

## 7) Remove As You Replace
- When reimplementing functionality, remove the old code once the new is fully working
- Do NOT keep dead code "for reference" - that's what git history and `Reference Only original/` are for
- Do NOT leave commented-out old implementations

## 8) Data Structures Policy

### 8a) Structs Over HashMaps
- Use typed structs for structured data, not `HashMap<String, Value>`
- `HashMap` is acceptable ONLY for genuinely dynamic keys (e.g., source names like "Source 1", "Source 2")

### 8b) Banned Patterns
| Bad | Good |
|-----|------|
| `HashMap<String, serde_json::Value>` | Typed struct |
| `Vec<HashMap<String, Value>>` | `Vec<TypedStruct>` |
| `Option<Box<dyn Any>>` | Proper enum or typed Option |

### 8c) Enums for Variants
- Use enums for values that can be one of several types
- Derive `Serialize`, `Deserialize` for persistence
- Use `#[serde(default)]` for backwards-compatible additions

## 9) Type Organization

### Shared Types: `vsg_core/src/models/`
Types used by 2+ unrelated modules:
- `enums.rs` - All enums (TrackType, AnalysisMode, etc.)
- `media.rs` - Track, StreamProps, Attachment
- `jobs.rs` - JobSpec, PlanItem, MergePlan, Delays

### Local Types: Stay in Module
Types used only within a module stay there:
- Step-specific output types in `orchestrator/types.rs`
- Analysis internals in `analysis/types.rs`

### Rule of Thumb
If you need to import a type into an unrelated module, consider moving it to `models/`.

## 10) Error Handling
- Use `thiserror` for error types
- Each module can have its own error type
- Steps convert module errors to `StepError`
- Provide context in error messages (what failed, with what inputs)

## 11) Architecture Layers
See `ARCHITECTURE.md` for full details. Summary:

```
ORCHESTRATOR (orchestrator/pipeline.rs)
    → Runs steps, handles cancellation, reports progress
    → No business logic

STEPS (orchestrator/steps/*.rs)
    → Coordinate, log, control flow, update JobState
    → Call module functions
    → 50-150 lines target
    → No algorithms or calculations

MODULES (analysis/, extraction/, chapters/, etc.)
    → ALL business logic
    → Pure functions: typed input → typed output
    → No Context/JobState access
    → Testable in isolation
```

## 12) Working with Python Reference
- `Reference Only original/` contains the original Python implementation
- Use it to understand WHAT features should do, not HOW to implement in Rust
- Compare behavior, not code structure
- Do NOT copy Python patterns that don't fit Rust idioms

## 13) Tests
- Add tests for non-trivial logic, especially in modules
- Test modules in isolation (they should be pure functions)
- Integration tests can use the orchestrator

## 14) Output Requirements
When producing code changes:
- Summarize what changed and why
- Note any behavior changes
- Confirm `cargo fmt`, `cargo clippy`, `cargo test` pass
