# AI Coding Rules (v2)

## 0) Prime directive
- Prioritize correctness, clarity, maintainability, and reproducibility over cleverness.

## 1) Discuss before changes (approval required)
- Do not implement or refactor anything non-trivial until you:
  1) explain the plan,
  2) list files/functions impacted,
  3) call out risks/tradeoffs,
  4) get explicit approval.
- Small, local fixes (typos, obvious bugfix in the same function) are allowed, but still explain what you changed.

## 2) Preserve behavior by default
- Maintain existing behavior unless an intentional change is explicitly approved.
- When changing behavior is necessary, clearly document:
  - what changes,
  - why it must change,
  - how it’s validated.

## 3) Dependencies are a discussion
- Do not add new libraries without proposing options + tradeoffs.
- Prefer fewer dependencies; justify any new one.
- If a library/version is uncertain, stop and discuss first.

## 4) Research, don’t assume
- When API/behavior is uncertain: consult official docs or upstream source.
- If you can’t verify: say so and propose the safest path.

## 5) Code style and tooling (Python)
- Python code MUST be:
  - formatted with **Black** (line length 88),
  - linted with **Ruff** (including import sorting),
  - type-checked with **Pyright** (basic mode).
- Do not hand-format or bikeshed formatting; rely on Black/Ruff outputs.
- Follow the repository's `pyproject.toml` settings.
- Commands:
  - `black .` - format code
  - `ruff check --fix .` - lint and auto-fix
  - `pyright` - type check (shows errors, manual fix)
  - `pre-commit run -a` - run all checks
- Pre-commit hooks are configured; install with `pre-commit install`.
- Current policy (gradual strictness):
  - Black: must pass (blocks commits)
  - Ruff: warnings shown but don't block (F841/F401 allowed for now)
  - Pyright: manual stage (run explicitly, doesn't block yet)

## 6) Gradual formatting policy (avoid giant diffs)
- Do NOT run mass reformat/lint across the entire repo unless explicitly requested.
- Default behavior:
  - format/lint only the files you touch,
  - keep diffs focused on the intended change.
- If a file is already being edited, it’s OK to format/lint that file as part of the change.

## 7) Type hints and readability
- Add type hints for all public functions and any non-trivial internal functions you modify/create.
- Pyright catches None-handling bugs (like Rust's Option type) - fix these when you see them.
- When adding type hints, run `pyright <file>` to verify correctness.
- Prefer small functions, clear naming, and predictable structure.
- Add comments/docstrings when intent is not obvious (explain WHY more than WHAT).

## 8) Tests / validation expectations
- For risky changes (parsing, timing, IO, concurrency, data transforms):
  - add/extend tests OR provide a clear validation plan (commands + expected output).
- Prefer preventing regressions over “looks correct”.

## 9) Rewrite/refactor quality rules
- If asked to rewrite/refactor:
  - keep feature parity unless approved otherwise,
  - remove single points of failure where feasible,
  - improve architecture without changing external behavior,
  - prefer incremental refactors over big rewrites unless requested.

## 10) Explicit ignore
- Do not read or use `Rust.tar.gz` (experiment; ignore completely).

---

## 11) Architecture: Where Code Belongs

### 11.1) The Three Layers

```
ORCHESTRATOR (vsg_core/orchestrator/pipeline.py)
    → Initializes Context, runs steps in sequence, validates

STEPS (vsg_core/orchestrator/steps/*.py)
    → Micro-orchestrators: coordinate, log, control flow, update Context
    → NO business logic

MODULES (vsg_core/analysis/, correction/, subtitles/, etc.)
    → ALL business logic as pure functions
    → Dataclasses for typed returns
    → No direct Context access
```

**Reference:** `analysis_step.py` is the gold standard - study it before modifying steps.

### 11.2) Steps vs Modules

| Put in STEP | Put in MODULE |
|-------------|---------------|
| Calling module functions | Algorithms, calculations |
| `runner._log_message(...)` | Complex conditionals |
| Loops over sources | Data transformations |
| Context reads/writes | Anything needing unit tests |

### 11.3) Module Function Pattern

```python
@dataclass
class ResultType:
    value: int
    raw_value: float

def do_thing(
    data: InputType,
    config: dict[str, Any],
    log: Callable[[str], None] | None = None,
) -> ResultType:
    # Pure function: data in → typed result out
    # Optional log callback, NO Context parameter
```

### 11.4) Models: Where Dataclasses Go

- **Shared types** → `vsg_core/models/` (check here first before creating new ones)
- **Domain-specific** → keep in module, re-export via `__init__.py`
- **Avoid duplicates** - search existing models before creating

**Imports:** Import from module's `__init__.py` (e.g., `from vsg_core.analysis import FinalDelay`), not internal files.

---

## 12) Output requirements
- When producing code changes:
  - summarize what changed and why,
  - note any behavior changes,
  - list how to run format/lint/tests for the touched files.
