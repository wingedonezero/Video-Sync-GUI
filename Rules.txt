# AI Coding Rules (v2)

## 0) Prime directive
- Prioritize correctness, clarity, maintainability, and reproducibility over cleverness.

## 1) Discuss before changes (approval required)
- Do not implement or refactor anything non-trivial until you:
  1) explain the plan,
  2) list files/functions impacted,
  3) call out risks/tradeoffs,
  4) get explicit approval.
- Small, local fixes (typos, obvious bugfix in the same function) are allowed, but still explain what you changed.

## 2) Preserve behavior by default
- Maintain existing behavior unless an intentional change is explicitly approved.
- When changing behavior is necessary, clearly document:
  - what changes,
  - why it must change,
  - how it’s validated.

## 3) Dependencies are a discussion
- Do not add new libraries without proposing options + tradeoffs.
- Prefer fewer dependencies; justify any new one.
- If a library/version is uncertain, stop and discuss first.
- Use latest stable librarys always check wen add a new lib

## 4) Research, don’t assume
- When API/behavior is uncertain: consult official docs or upstream source.
- If you can’t verify: say so and propose the safest path.

## 5) Type hints and readability
- Add type hints for all public functions and any non-trivial internal functions you modify/create.
- Prefer small functions, clear naming, and predictable structure.
- Add comments/docstrings when intent is not obvious (explain WHY more than WHAT).

## 6) Tests / validation expectations
- For risky changes (parsing, timing, IO, concurrency, data transforms):
  - add/extend tests OR provide a clear validation plan (commands + expected output).
- Prefer preventing regressions over “looks correct”.

## 7) Rewrite/refactor quality rules
- If asked to rewrite/refactor:
  - keep feature parity unless approved otherwise,
  - remove single points of failure where feasible,
  - improve architecture without changing external behavior,
  - prefer incremental refactors over big rewrites unless requested.

## 8) Output requirements
- When producing code changes:
  - summarize what changed and why,
  - note any behavior changes,

---

# Rust Rewrite Guidelines

## 9) Python Reference Folder

- `Original Python Codebase/` is the **reference implementation only**
- Purpose: Blueprint for rewriting to Rust - study the logic, not copy the patterns
- The Rust version should be **better**: stronger types, no dict chaos, modular, testable
- UI files are blueprints for layout/flow - replicate UX, not implementation

### Removing Python code
- **Never delete Python files without explicit approval**
- Only request removal when:
  1. The equivalent Rust code is 100% complete
  2. All features from that Python module are implemented
  3. Tests/validation confirm feature parity
- Ask before removal: "Module X is fully rewritten. Approve removal of Python file Y?"
- Track progress: note which Python modules remain vs completed

## 10) Rust Architecture (strict hierarchy)

```
ORCHESTRATOR (vsg_core/orchestrator/)
  → Owns Context, runs steps in sequence, validates between steps
  → Single source of truth for job state

STEPS (vsg_core/orchestrator/steps/)
  → Micro-orchestrators: coordinate modules, log progress, update Context
  → NO business logic - only control flow and delegation
  → Each step validates its inputs/outputs

MODULES (vsg_core/analysis/, correction/, subtitles/, etc.)
  → ALL business logic lives here as pure functions
  → Return typed structs, never modify Context directly
  → Steps call modules, modules never call steps
```

### Data flow rules
- Context is read-only to modules; only steps mutate JobState
- Modules return `Result<TypedStruct, Error>` - steps decide what to do
- No `HashMap<String, Value>` for known shapes - use structs with named fields

## 11) Data Structures (Rust)

- **Always use structs/enums** - never untyped maps for known shapes
- **Define types close to usage** - `models/` for shared, local `types.rs` for module-specific
- **Single source of truth** - one canonical type per concept (e.g., one `Delays` struct)
- **Derive traits consistently**: `Debug, Clone, Serialize, Deserialize` on all data types
- **Use newtype wrappers** for domain concepts (e.g., `Milliseconds(f64)`, `TrackId(u32)`)

## 12) UI Framework (GTK4 + Relm4)

- UI lives in `vsg_ui` crate, depends on `vsg_core`
- **Relm4 pattern**: Components with Model, Widgets, Messages
- **No business logic in UI** - call vsg_core functions, display results
- Keep UI state separate from core job state
- Use async channels for long operations (analysis, mux)

## 13) No Duplication

- Before adding a type/function, search for existing ones
- One module owns each concept - others import, never redefine
- If two places need similar logic, extract to shared module
- Conversion functions live with the target type (`impl From<X> for Y` on Y)
